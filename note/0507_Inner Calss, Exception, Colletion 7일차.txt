### 내부클래스 (Inner Class) ###

1. 클래스 내에 클래스를 선언하여 사용
 1) Why? 
   (1) 클래스 내부에서만 사용하는 데이터/기능 들을 캡슐화 하기 위한 목적 = 클래스 내에서만 사용하는 데이터/기능들을 클래스 내부에만 두겠다.
   (2) 익명내부클래스(anonymous inner class) : 한번만 사용할 객체를 생성하기 위해서
 2) 내부클래스 분류
   (1) non-static inner class : 외부클래스의 non-static 멤버변수 레벨 취급을 받는다.
   (2) static inner class : 외부클래스의 static 멤버변수 레벨 취급을 받는다.
   (3) local inner class  : 메소드내에 선언해서 메소드가 수행이 종료되면 없어짐
   (4) annoymous inner class : 일반적으로 이벤트처리 시 이벤트처리함수(이벤트핸들러)로 사용되는 이름없는 클래스

* 내부클래스는 꼭 필요한 경우 또는 사용하여 큰 이점이 있는 경우에만 한정적으로 사용하는 것이 객체지향설계를 깨지 않는 습관임.

* outer$inner.... : $표시가 있으면 내부클래스인지 확인해야함.


### 예외처리 (Exception Handling) ###
 
* 에러(error)와 예외(exception)
 1) 에러 : 프로그래머가 코드로 처리할 수  없는 오류(ex : 네트워크 장애, 파일장애, 데이터베이스 장애, 메모리부족)
 2) 에외 : 프로그래머가 코드로 처리할 수 있는 오류

* RuntimeException, IOException, SQLException 주로 발생.... 주목
* 프로그램상에서 발생 가능한 모든 예외는 "무조건" 처리해야 한다.
* 예외처리 구문
  1) try {} : 예외 발생 가능한 코드 블록
  2) catch (예외클래스) {} : 예외처리블록, 1개 이상
  3) finally{}
     : 예외발생여부에 상관없이 무조건 수행되는 코드블록
     : 예) 예외발생해도 데이터베이스 커넥션(연결)을 닫아야 하는 경우
           파일을 열어서 썼는데 예외 발생했을 때 안닫힐거에 대비하여(메모리가 계속 쓰이니깐)

*예외처리는 catch 구문에서 일어나는데 하위Exception > 상위Exception 순으로 catch 구문을 작성해야 한다.
예) try {
	int i = 1000 / 0; // DevideByZeroException 발생
      }
      catch(DevideByZeroException dbze) {
        // 발생한 예외 처리
      }
     catch (Exception ex) {
        // DevideByZeroException을 제외한 모든 예외를 처리
      }

* 예외처리 원칙은 try 구문에서 발생할 수 있는 모든 예외에 대해 각각 catch절에서 처리해 주는 것
* throws : 호출한 쪽에 예외처리를 넘김
* throw : 예외를 강제로 발생시킬때 사용하는 키워드 _ 특정상황에 throw 활용 예외를 만들어 처리하기 위해서
* 사용자정의예외(User Defined Exception)
   : Exception 클래스를 상속받아서 예외를 생성해서 사용
   : 예) 영화관람 연령제한, 비행기 연착시점, 


### 컬렉션 프레임워크(Collection Framework) ###

* 컬렉션프레임워크 : < > 안에 모든 참조타입을 담을 수 있으나 사용시에는 단일타입만 담음 _ 여러개 담으면 나중에 사용하기 힘듬.
  1) 자바에서 참조타입의 모음을 정의한 것
  2) 크게 Collection  인터페이스 계열과 Map인터페이스 계열로 구분
  3) Collection인터페이스는 List인터페이스 계열과  Set인터페이스 계열로 구분


* List
  1) 순서(인덱스)가 있고, 중복된 값 저장 가능 / 참조타입만 담을 수 있으며 확장성(크기가 안정해져 있음)이 좋음
  2) 크게 ArrayList, LinkedList가 많이 사용됨
  3) ArrayList : 연속적으로 데이터를 저장,  저장된 값 검색시 빠름, 요소를 추가/삭제/변경 느림
  4) LinkedList : 서로 떨어진 위치에서 서로의 위치를 참조하는 방식으로 저장, 검색시 느림, 요소를 추가/삭제/변경 빠름
  5) 검색이 많은 작업 시는 ArrayList가 속도면에서 유리, 추가/삭제/변경이 많은 작업시는 LinkedList가 유리


* Set
  1) 순서가 없고, 중복된 값은 저장 불가
  2) 크게 HashSet, SortedSet 정도가 사용된다.
    - Hash : 속도가 올랐다.
    - Sorted : 정렬됬다.

* Map
  1) 순서가 없고 중복 : 키는 중복 불가, 값은 중복 가능
  2) 키와 값을 합쳐서 (Map.Entry)라고 함
  3) 맵은 엔트리들의 집합, 맵의 최소단위는 엔트리
  4) 맵은 다수의 객체를 값으로 저장하고 키를 통해서 빠른 검색을 하기 위한 자료구조