### 접근지정자(Access Modifier)###
접근지정자(접근제한자)
1. public
 1) 모든 패키지에서 접근 가능

2. protected
 1) 동일 패키지 or 다른 패키지에 있더라도 상속 관계일떄 접근 가능

3. default
 1) 동일 패키지에서 접근 가능

4. private
 1) 클래스 내에서만(캡슐화_Encapsulation : 정보은닉(information hiding)) 접근 가능

public static void main(String[] args){ }

*(dafault)가 붙어 있는 경우_생략된거임
int add(int x, int y) {
    return x + y; 
}

* 접근제한자는 항상 맨 앞에 서술하는게 관례
 - 클래스 : public, (default) 사용 가능
 - 멤버변수, 메소드, 생성자 : public, protected, (default), private 사용 가능


* 캡슐화(Encapsulation) : 클래스내의 데이터를 보호하기 위해서 클래스 외부에서의 직접 접근을 막는다.
  = 정보은닉(information hiding)

* 캡슐화의 목적
  1. 데이터를 가진쪽에서 데이터의 원본을 보호(숨김)
  2. 데이터가 필요한곳에 제공자가 원하는 형태(값)으로 데이터를 제공

Data Object(Value Object = Java Bean) : 데이터를 정의하는 것(?)

Human 클래스의 private 을 HumanMain에서 getter와 setter를 통해 데이터를 가져올 수는 있지만
원래 있었던 정보를 알 수 없다.



### 객체지향 3대 개념###

1. 상속(Inheritance)
  1). 상위 클래스(Super, Parent)의 변수와 메소드를 하위 클래스(sub, child, derived)에서 상속받아 사용하는 것(A extends B : A가 B의 클래스를 상속받는다)
  2). 상위클래스가 private인 것들은 상속에서 제외
  3). 상속이 여러단계에 걸쳐서 일어나면 상속트리(tree, hierachy)가 생성된다.
  4). 상속의 장점 : 재사용(reusing) - 이미 만들어진 것을 직접 만들지 않고 재사용 할 수 있다.
  5). 상속의 단점
   (1). 상속트리가 커질수록 내가 사용하는 것이 어디에 위치한지 알기 어렵다
   (2). 상위클래스를 잘못 만들경우 하위 클래스가 영향을 받는다.
   (3). 사용하지 않는 불필요한 것들을 다수 상속받을 수 있게 된다.

상속을 extends로 쓰는 이유
 - 상속받는 순간  하위 클래스의 참조범위는 상위클래스의 참조범위를 포함하게 된다. 즉 Heap메모리에 상위, 하위 클래스가 나란히 하게 된다.
 - 즉 참조범위는 하위로 갈수록 넓어진다.


2. 추상화(Abstraction)
  1). 본연의 성질을 잃어버리지 않는 선에서 최대한 단순화 즉, 대부분의 사람들이 같은 생각이 들게끔 하는것 , 단순화시킬수록 추상화 단계가 높다.
  2). 클래스는 현실세계의 사물이나 개념에 대한 추상화의 산물

3. 다형성(Polymophism) 
  1). 하나의 형태로 다양한 성질을 갖도록 하는 개념.(ex. 오버로딩(oveloading), 오버라이딩(overriding)_상속관계에 있는 경우), java.ioDataOutputStream
   (1). 오버로딩(oveloading) : 생성자나 메소드의 이름을 동일하게 하고, 파라미터의 개수, 순서, 타입을 달리 해서 하나의 이름으로 기능 호출하는 방법
   (2). 오버라이딩(overriding) : 메소드 재정의_상위클래스에서 하위클래스를 호출 - 호출의 단일화
    가. 오버라이딩의 조건
     가). 두 클래스가 상속 관계에 있어야 한다.
     나). 상속받는 측에서 접근제한자가 덜 접근 제한적이어야 한다. (상위 default > 하위 defalut, protected, public)
     다). 반환타입이 같아야 한다. (생성자는 오버라이딩X, 메소드 오버라이딩)
     라). 메소드명이 동일해야 한다.
     마). 파라미터리스트(개수, 순서, 타입)가 동일해야 한다. => 상위메소드와 하위메소드가 같은 메소드라는 얘기
     바). 상위 클래스의 메소드와 하위클래스의 메소드가 같은 시그니쳐를 가지고 있다.
   - method signautre : 접근제한자 반환타입 메소드명(파라미터리스트)


### 참조타입의 형변환 (reference type casting) ###
  - 참조범위에 대해서 생각하라! / 상속관계에 있어야 형변환 가능
  - 하위타입을 상위타입으로 형변환 할 때는 자동형변환 (상위형변환, 묵시적형변환, implicit type casting)
  - 상위타입을 하위타입으로 형변환 할 떄는 강제형변환 (하위형변환, 명시적형변환, explicit type casting)
  - 하위형변환을 하려면 한번은 상위형변환이 된 경험이 있어야 함.

* final 키워드
 - 클래스 앞에 final : 상속 불가
 - 메소드 앞에 fianl : 오버라이딩 불가
 - 변수 앞에 final : 상수(constant, 한번 값이 정해지면 변경할 수 없는 변수)
   상수명은 각 단어를 대문자로 _로 붙인다.
   상수는 반드시 초기화하고 사용한다.












